<!DOCTYPE html>
<html lang="en">
	<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Hello World! - Kostas "xkon" Xenos</title>
        <meta name="description" content="Kostas 'xkon' Xenos' personal website.">
        <link rel="shortcut icon" href="data:," />
		<style>
			@import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500&display=swap");

			:root {
				font-family: "Space Grotesk", "Segoe UI", sans-serif;
				--sky-deep: #010812;
				--sky-mid: #071b2d;
				--sky-glow: #8a5a2b;
				--sand-warm: #f2d7a5;
			}

			* {
				box-sizing: border-box;
			}

			body {
				margin: 0;
				min-height: 100vh;
				display: flex;
				flex-direction: column;
				background-image: radial-gradient(circle, var(--sky-glow), transparent 70%),
					linear-gradient(var(--sky-deep), var(--sky-mid));
				background-repeat: no-repeat;
				background-size: 900px 900px, 100% 100%;
				background-position: -200px -250px, 0 0;
				color: #f6f1e7;
			}

            a,
            a:hover,
            a:visited,
            a:focus,
            a:active {
                color: #fff;
            }

			main {
				position: fixed;
                top: 3rem;
                left: 3rem;
			}

			.masthead {
				max-width: 60ch;
				display: flex;
				flex-direction: column;
				gap: 1rem;
			}

			.eyebrow {
				letter-spacing: 0.35em;
				text-transform: uppercase;
				font-size: 0.8rem;
				color: #f3c481;
				margin: 0;
			}

			.lede {
				margin: 0;
				font-size: 1.2rem;
				color: rgba(246, 241, 231, 0.85);
                padding-right: 3rem;
			}

			.scene {
				position: fixed;
				bottom: 0;
				left: 0;
				width: 100%;
				height: 50vh;
				min-height: 360px;
				overflow: hidden;
				background: linear-gradient(rgba(5, 15, 30, 0), rgba(5, 15, 30, 0.85));
				z-index: 0;
			}

			.scene canvas {
				position: absolute;
				inset: 0;
				width: 100%;
				height: 100%;
				display: block;
			}

			.scene-haze {
				position: absolute;
				inset: 0;
				background: linear-gradient(to top, rgba(1, 8, 18, 0.75), transparent 60%);
				pointer-events: none;
			}

			.fallback {
				display: flex;
				align-items: center;
				justify-content: center;
				color: rgba(246, 241, 231, 0.8);
				font-size: 1rem;
				text-align: center;
				padding: 2rem;
			}

			.mantra {
				position: absolute;
				bottom: 1.5rem;
				left: 50%;
				transform: translateX(-50%);
				text-align: center;
				letter-spacing: 0.35em;
				text-transform: lowercase;
				font-size: 0.9rem;
				color: #ffffff;
				margin: 0;
			}
		</style>
	</head>
	<body>
		<main>
			<header class="masthead">
				<p class="eyebrow">arrakis dispatch</p>
				<p class="lede">
                    I'm Kostas, CTO of <a href="https://incsub.com" target="_blank">Incsub</a>, working with the amazing people behind <a href="https://wpmudev.com" target="_blank">WPMU DEV</a>, <a href="https://campuspress.com" target="_blank">CampusPress</a> and <a href="https://edublogs.org" target="_blank">Edublogs</a> while snooping around and <a href="https://profiles.wordpress.org/xkon/" target="_blank">contributing</a> to WordPress as the usual <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging" target="_blank">Rubber Duck Debugger</a>.<br><br>Proud member of the <a href="https://wpgreece.org/" target="_blank">WordPress Greek Community</a> as a <a href="https://wordcamp.org/" target="_blank">WordCamp &amp; Meetup organizer</a>.<br><br>Advocate of quality code, supporter of FOSS and part of the awesome WP Lemon team that brought to you Kirki Customizer Framework, Gridd Theme and other goodies.<br><br>When not online or coding, I spend my time djing &amp; making beats, drawing or tattooing.
				</p>
			</header>
		</main>
		<section class="scene">
			<canvas id="dune-canvas" aria-hidden="true"></canvas>
			<div class="scene-haze" aria-hidden="true"></div>
			<p class="mantra">dreams are messages from the deep</p>
		</section>
		<noscript>
			<p class="fallback">Enable JavaScript to see the dunes ripple in 3D.</p>
		</noscript>
		<script type="module">
			import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";

			const container = document.querySelector(".scene");
			const canvas = document.getElementById("dune-canvas");

			if (!container || !canvas) {
				throw new Error("Missing scene elements.");
			}

			const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.8));
			renderer.setClearColor(0x000000, 0);

			const scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2(0x030b13, 0.03);

			const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 200);
			camera.position.set(0, 14, 36);
			camera.lookAt(0, 4, 0);

			const duneGroup = new THREE.Group();
			duneGroup.position.set(0, -6, -12);
			duneGroup.rotation.x = -0.22;
			scene.add(duneGroup);

			const duneConfig = {
				width: 40,
				depth: 55,
				segmentsX: 320,
				segmentsZ: 200,
			};

			const hillProfiles = [
				{ x: -32, z: 12, radius: 18, height: 6.4 },
				{ x: 8, z: 18, radius: 22, height: 5.2 },
				{ x: 35, z: 24, radius: 26, height: 6.8 },
				{ x: -10, z: 34, radius: 124, height: 4.2 },
			];

			const cols = duneConfig.segmentsX + 1;
			const rows = duneConfig.segmentsZ + 1;
			const dunePoints = cols * rows;
			const positions = new Float32Array(dunePoints * 3);
			const basePositions = new Float32Array(dunePoints * 3);
			const colors = new Float32Array(dunePoints * 3);
			const waveOffsets = new Float32Array(dunePoints);
			const color = new THREE.Color();

			let ptr = 0;
			for (let zi = 0; zi < rows; zi += 1) {
				const depthNorm = zi / (rows - 1);
				for (let xi = 0; xi < cols; xi += 1) {
					const widthNorm = xi / (cols - 1);
					const x = (widthNorm - 0.5) * duneConfig.width;
					const z = depthNorm * duneConfig.depth;
					const baseRise = Math.pow(1 - depthNorm, 1.8) * 3.2;
					const lateralRidge = Math.sin(widthNorm * Math.PI) * 0.9;
					const microRipples = Math.sin(widthNorm * 14 + depthNorm * 5) * 0.45;
					let hillHeight = 0;
					for (const hill of hillProfiles) {
						const dx = x - hill.x;
						const dz = z - hill.z;
						const falloff = Math.exp(-(dx * dx + dz * dz) / (2 * hill.radius * hill.radius));
						hillHeight += falloff * hill.height;
					}
					const y = baseRise + lateralRidge + microRipples + hillHeight;

					positions[ptr] = x;
					positions[ptr + 1] = y;
					positions[ptr + 2] = z;
					basePositions[ptr] = x;
					basePositions[ptr + 1] = y;
					basePositions[ptr + 2] = z;

					const satBase = 0.6 - depthNorm * 0.12 + hillHeight * 0.01;
					const lightBase = 0.78 - depthNorm * 0.2 + hillHeight * 0.015 + (Math.random() - 0.5) * 0.03;
					const saturation = Math.max(0.45, Math.min(0.78, satBase));
					const lightness = Math.max(0.5, Math.min(0.94, lightBase));
					color.setHSL(0.1, saturation, lightness);
					colors[ptr] = color.r;
					colors[ptr + 1] = color.g;
					colors[ptr + 2] = color.b;

					waveOffsets[ptr / 3] = Math.random() * Math.PI * 2;
					ptr += 3;
				}
			}

			const duneGeometry = new THREE.BufferGeometry();
			duneGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
			duneGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

			const duneMaterial = new THREE.PointsMaterial({
				size: 0.02,
				sizeAttenuation: true,
				vertexColors: true,
				transparent: true,
				opacity: 0.95,
			});

			const duneDots = new THREE.Points(duneGeometry, duneMaterial);
			duneGroup.add(duneDots);

			const dustCount = 160;
			const dustPositions = new Float32Array(dustCount * 3);
			const dustGeometry = new THREE.BufferGeometry();
			dustGeometry.setAttribute("position", new THREE.BufferAttribute(dustPositions, 3));

			const dustMaterial = new THREE.PointsMaterial({
				color: new THREE.Color(0xffedd1),
				size: 0.35,
				transparent: true,
				opacity: 0.8,
				blending: THREE.AdditiveBlending,
				depthWrite: false,
			});

			const dustCloud = new THREE.Points(dustGeometry, dustMaterial);
			duneGroup.add(dustCloud);

			const dustVelocities = Array.from({ length: dustCount }, () => new THREE.Vector3());
			const dustLife = new Float32Array(dustCount).fill(1);
			const dustMaxLife = new Float32Array(dustCount).fill(0);
			const dustActive = new Array(dustCount).fill(false);

			const hideDust = (index) => {
				const i3 = index * 3;
				dustPositions[i3] = 0;
				dustPositions[i3 + 1] = -999;
				dustPositions[i3 + 2] = 0;
				dustActive[index] = false;
			};

			for (let i = 0; i < dustCount; i += 1) {
				hideDust(i);
			}

			const activateDust = (index, direction) => {
				const i3 = index * 3;
				const startX = (Math.random() - 0.5) * duneConfig.width * 0.25;
				const startZ = Math.random() * 8 + 2;
				const startY = Math.random() * 1.5 + 0.5;
				dustPositions[i3] = startX;
				dustPositions[i3 + 1] = startY;
				dustPositions[i3 + 2] = startZ;
				dustVelocities[index].set(
					(0.8 + Math.random() * 1.3) * direction,
					Math.random() * 0.7 + 0.1,
					-1.2 - Math.random() * 1.3
				);
				dustLife[index] = 0;
				dustMaxLife[index] = 1.8 + Math.random() * 1.7;
				dustActive[index] = true;
			};

			const triggerGust = () => {
				const direction = Math.random() > 0.5 ? 1 : -1;
				let spawned = 0;
				const burstSize = 18 + Math.floor(Math.random() * 22);
				for (let i = 0; i < dustCount && spawned < burstSize; i += 1) {
					if (dustActive[i]) {
						continue;
					}
					activateDust(i, direction);
					spawned += 1;
				}
			};

			const scheduleGust = () => {
				const delay = 1600 + Math.random() * 2600;
				setTimeout(() => {
					triggerGust();
					scheduleGust();
				}, delay);
			};
			scheduleGust();

			const resizeRenderer = () => {
				const { clientWidth, clientHeight } = container;
				renderer.setSize(clientWidth, clientHeight, false);
				camera.aspect = clientWidth / clientHeight;
				camera.updateProjectionMatrix();
			};

			const observer = new ResizeObserver(resizeRenderer);
			observer.observe(container);
			resizeRenderer();

			let lastTime = performance.now();

			const animate = (time) => {
				const delta = (time - lastTime) / 1000;
				lastTime = time;

				const pos = duneGeometry.attributes.position.array;
				for (let i = 0; i < pos.length; i += 3) {
					const depthNorm = basePositions[i + 2] / duneConfig.depth;
					const offset = Math.sin(time * 0.0005 + waveOffsets[i / 3]) * 0.25;
					pos[i + 1] = basePositions[i + 1] + offset * (1 - depthNorm * 0.6);
				}
				duneGeometry.attributes.position.needsUpdate = true;

				for (let i = 0; i < dustCount; i += 1) {
					if (!dustActive[i]) {
						continue;
					}
					const i3 = i * 3;
					dustLife[i] += delta;
					if (dustLife[i] >= dustMaxLife[i]) {
						hideDust(i);
						continue;
					}
					dustPositions[i3] += dustVelocities[i].x * delta * 4;
					dustPositions[i3 + 1] += dustVelocities[i].y * delta * 4;
					dustPositions[i3 + 2] += dustVelocities[i].z * delta * 4;
					dustVelocities[i].x *= 1 - 0.08 * delta;
					dustVelocities[i].z -= 0.4 * delta;
				}
				dustGeometry.attributes.position.needsUpdate = true;

				renderer.render(scene, camera);
				requestAnimationFrame(animate);
			};

			requestAnimationFrame(animate);
		</script>
	</body>
</html>
